/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   indexing.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: your_login <your_login@student.42.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/16 15:00:00 by your_login        #+#    #+#             */
/*   Updated: 2025/04/16 15:55:47 by rakman           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../inc/push_swap.h"

static void	sort_integer_array(int *arr, int size)
{
	int	i;
	int	j;
	int	temp;

	i = 0;
	while (i < size - 1)
	{
		j = 0;
		while (j < size - 1 - i)
		{
			if (arr[j] > arr[j + 1])
			{
				temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
			j++;
		}
		i++;
	}
}

static int	*copy_stack_to_array(t_node *stack, int size)
{
	int	*arr;
	int	i;

	arr = (int *)malloc(sizeof(int) * size);
	if (!arr)
		return (NULL);
	i = 0;
	while (stack && i < size)
	{
		arr[i] = stack->value;
		stack = stack->next;
		i++;
	}
	return (arr);
}

static int	find_index_in_array(int *sorted_arr, int size, int value)
{
	int	i;

	i = 0;
	while (i < size)
	{
		if (sorted_arr[i] == value)
			return (i);
		i++;
	}
	return (-1);
}

void	assign_indices(t_stacks *stacks)
{
	int		*temp_array;
	t_node	*current;
	int		index;
	int		size;

	size = stacks->size_a;
	if (size <= 1)
		return ;
	temp_array = copy_stack_to_array(stacks->a, size);
	if (!temp_array)
		return ;
	sort_integer_array(temp_array, size);
	current = stacks->a;
	while (current)
	{
		index = find_index_in_array(temp_array, size, current->value);
		current->index = index;
		current = current->next;
	}
	free(temp_array);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   push_swap_main_logic.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: your_login <your_login@student.42.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/16 15:00:00 by your_login        #+#    #+#             */
/*   Updated: 2025/04/16 15:55:54 by rakman           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../inc/push_swap.h"

void	push_swap(t_stacks *stacks)
{
	stacks->size_a = get_stack_size(stacks->a);
	stacks->size_b = 0;
	if (is_sorted(stacks->a) || stacks->size_a <= 1)
		return ;
	if (stacks->size_a <= 5)
	{
		sort_small(stacks);
	}
	else
	{
		assign_indices(stacks);
		radix_sort(stacks);
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   radix_sort.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: your_login <your_login@student.42.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/16 15:00:00 by your_login        #+#    #+#             */
/*   Updated: 2025/04/16 15:55:59 by rakman           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../inc/push_swap.h"

static int	get_max_bits(int max_index)
{
	int	bits;

	bits = 0;
	while (max_index > 0 && (max_index >> bits) != 0)
	{
		bits++;
	}
	if (max_index > 0 && bits == 0)
		return (1);
	return (bits);
}

void	radix_sort(t_stacks *stacks)
{
	int		i;
	int		j;
	int		size;
	int		max_bits;
	t_node	*current_a;

	size = stacks->size_a;
	max_bits = get_max_bits(size - 1);
	i = 0;
	while (i < max_bits)
	{
		j = 0;
		while (j < size)
		{
			current_a = stacks->a;
			if (((current_a->index >> i) & 1) == 0)
				pb(stacks);
			else
				ra(stacks);
			j++;
		}
		while (stacks->size_b != 0)
		{
			pa(stacks);
		}
		i++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   sort_small.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: your_login <your_login@student.42.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/16 15:00:00 by your_login        #+#    #+#             */
/*   Updated: 2025/04/16 15:56:08 by rakman           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../inc/push_swap.h"

static void	sort_two(t_stacks *stacks)
{
	if (stacks->a->value > stacks->a->next->value)
		sa(stacks);
}

static void	sort_three(t_stacks *stacks)
{
	t_node	*h;
	t_node	*m;
	t_node	*t;

	h = stacks->a;
	if (!h || !h->next || !h->next->next || is_sorted(h))
		return ;
	m = h->next;
	t = m->next;
	if (h->value > m->value && m->value < t->value && h->value < t->value)
		sa(stacks);
	else if (h->value > m->value && m->value > t->value)
	{
		sa(stacks);
		rra(stacks);
	}
	else if (h->value > m->value && m->value < t->value && h->value > t->value)
		ra(stacks);
	else if (h->value < m->value && m->value > t->value && h->value < t->value)
	{
		sa(stacks);
		ra(stacks);
	}
	else if (h->value < m->value && m->value > t->value && h->value > t->value)
		rra(stacks);
}

static void	bring_min_to_top(t_stacks *stacks)
{
	int	min_pos;
	int	size;

	size = stacks->size_a;
	min_pos = find_min_index_pos(stacks->a);
	if (min_pos < 0)
		return ;
	if (min_pos <= size / 2)
	{
		while (min_pos-- > 0)
			ra(stacks);
	}
	else
	{
		while (min_pos++ < size)
			rra(stacks);
	}
}

static void	sort_four_five(t_stacks *stacks)
{
	while (stacks->size_a > 3)
	{
		bring_min_to_top(stacks);
		pb(stacks);
	}
	sort_three(stacks);
	while (stacks->size_b > 0)
	{
		pa(stacks);
	}
}

void	sort_small(t_stacks *stacks)
{
	assign_indices(stacks);
	if (stacks->size_a == 2)
		sort_two(stacks);
	else if (stacks->size_a == 3)
		sort_three(stacks);
	else if (stacks->size_a <= 5)
		sort_four_five(stacks);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   stack_ops_rev_rotate.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: your_login <your_login@student.42.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/16 15:00:00 by your_login        #+#    #+#             */
/*   Updated: 2025/04/16 15:56:17 by rakman           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../inc/push_swap.h"

static void	reverse_rotate(t_node **stack)
{
	t_node	*last;
	t_node	*second_last;

	if (!stack || !*stack || !(*stack)->next)
		return ;
	last = *stack;
	while (last->next != NULL)
		last = last->next;
	second_last = last->prev;
	if (second_last)
		second_last->next = NULL;
	else
		(*stack)->next = NULL;
	last->prev = NULL;
	last->next = *stack;
	(*stack)->prev = last;
	*stack = last;
}

void	rra(t_stacks *stacks)
{
	if (stacks->a && stacks->a->next)
	{
		reverse_rotate(&(stacks->a));
		ft_printf("rra\n");
	}
}

void	rrb(t_stacks *stacks)
{
	if (stacks->b && stacks->b->next)
	{
		reverse_rotate(&(stacks->b));
		ft_printf("rrb\n");
	}
}

void	rrr(t_stacks *stacks)
{
	bool	rotated;

	rotated = false;
	if (stacks->a && stacks->a->next)
	{
		reverse_rotate(&(stacks->a));
		rotated = true;
	}
	if (stacks->b && stacks->b->next)
	{
		reverse_rotate(&(stacks->b));
		rotated = true;
	}
	if (rotated)
		ft_printf("rrr\n");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   stack_ops_rotate.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: your_login <your_login@student.42.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/16 15:00:00 by your_login        #+#    #+#             */
/*   Updated: 2025/04/16 15:56:30 by rakman           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../inc/push_swap.h"

static void	rotate(t_node **stack)
{
	t_node	*first;
	t_node	*last;

	if (!stack || !*stack || !(*stack)->next)
		return ;
	first = *stack;
	last = *stack;
	while (last->next != NULL)
		last = last->next;
	*stack = first->next;
	(*stack)->prev = NULL;
	last->next = first;
	first->prev = last;
	first->next = NULL;
}

void	ra(t_stacks *stacks)
{
	if (stacks->a && stacks->a->next)
	{
		rotate(&(stacks->a));
		ft_printf("ra\n");
	}
}

void	rb(t_stacks *stacks)
{
	if (stacks->b && stacks->b->next)
	{
		rotate(&(stacks->b));
		ft_printf("rb\n");
	}
}

void	rr(t_stacks *stacks)
{
	bool	rotated;

	rotated = false;
	if (stacks->a && stacks->a->next)
	{
		rotate(&(stacks->a));
		rotated = true;
	}
	if (stacks->b && stacks->b->next)
	{
		rotate(&(stacks->b));
		rotated = true;
	}
	if (rotated)
		ft_printf("rr\n");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   stack_ops_swap_push.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: your_login <your_login@student.42.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/16 15:00:00 by your_login        #+#    #+#             */
/*   Updated: 2025/04/16 15:56:23 by rakman           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../inc/push_swap.h"

static void	swap(t_node **stack)
{
	t_node	*first;
	t_node	*second;
	t_node	*third;

	if (!stack || !*stack || !(*stack)->next)
		return ;
	first = *stack;
	second = first->next;
	third = second->next;
	first->next = third;
	if (third)
		third->prev = first;
	second->prev = first->prev;
	first->prev = second;
	second->next = first;
	*stack = second;
}

static void	push(t_node **from, t_node **to)
{
	t_node	*node_to_move;

	if (!from || !*from)
		return ;
	node_to_move = *from;
	*from = (*from)->next;
	if (*from)
		(*from)->prev = NULL;
	node_to_move->prev = NULL;
	if (!*to)
	{
		*to = node_to_move;
		node_to_move->next = NULL;
	}
	else
	{
		node_to_move->next = *to;
		(*to)->prev = node_to_move;
		*to = node_to_move;
	}
}

void	sa(t_stacks *stacks)
{
	if (stacks->a && stacks->a->next)
	{
		swap(&(stacks->a));
		ft_printf("sa\n");
	}
}

void	sb(t_stacks *stacks)
{
	if (stacks->b && stacks->b->next)
	{
		swap(&(stacks->b));
		ft_printf("sb\n");
	}
}

void	ss(t_stacks *stacks)
{
	bool	swapped;

	swapped = false;
	if (stacks->a && stacks->a->next)
	{
		swap(&(stacks->a));
		swapped = true;
	}
	if (stacks->b && stacks->b->next)
	{
		swap(&(stacks->b));
		swapped = true;
	}
	if (swapped)
		ft_printf("ss\n");
}

void	pa(t_stacks *stacks)
{
	if (stacks->b)
	{
		push(&(stacks->b), &(stacks->a));
		stacks->size_a++;
		stacks->size_b--;
		ft_printf("pa\n");
	}
}

void	pb(t_stacks *stacks)
{
	if (stacks->a)
	{
		push(&(stacks->a), &(stacks->b));
		stacks->size_a--;
		stacks->size_b++;
		ft_printf("pb\n");
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   stack_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: your_login <your_login@student.42.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/16 15:00:00 by your_login        #+#    #+#             */
/*   Updated: 2025/04/16 15:56:38 by rakman           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../inc/push_swap.h"

int	get_stack_size(t_node *stack)
{
	int	size;

	size = 0;
	while (stack)
	{
		size++;
		stack = stack->next;
	}
	return (size);
}

bool	is_sorted(t_node *stack)
{
	if (!stack)
		return (true);
	while (stack->next)
	{
		if (stack->value > stack->next->value)
			return (false);
		stack = stack->next;
	}
	return (true);
}

void	free_stacks(t_stacks *stacks)
{
	ft_free_list(stacks->a);
	ft_free_list(stacks->b);
	stacks->a = NULL;
	stacks->b = NULL;
}

int	find_min_index_pos(t_node *stack)
{
	int	min_idx;
	int	min_pos;
	int	curr_pos;

	if (!stack)
		return (-1);
	min_idx = stack->index;
	min_pos = 0;
	curr_pos = 0;
	while (stack)
	{
		if (stack->index < min_idx)
		{
			min_idx = stack->index;
			min_pos = curr_pos;
		}
		stack = stack->next;
		curr_pos++;
	}
	return (min_pos);
}
